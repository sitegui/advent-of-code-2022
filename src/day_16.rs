use crate::data::Data;
use crate::nom_parser::*;
use crate::DayOutput;
use itertools::Itertools;
use petgraph::algo::dijkstra;
use petgraph::prelude::*;
use std::cmp::Reverse;
use std::collections::{HashMap, HashSet};
use std::iter;

#[derive(Debug, Clone)]
struct ParsedValve {
    name: ValveName,
    flow: i32,
    neighbors: Vec<ValveName>,
}

#[derive(Debug, Clone)]
struct Valve {
    flow: i32,
    connected_valves: HashMap<ValveName, i32>,
}

type ValveName = [u8; 2];

pub fn solve(data: &Data) -> DayOutput {
    let all_valves = lines(parse_valve).consume_all(data.bytes());

    let mut complete_graph = DiGraphMap::new();
    for valve in &all_valves {
        complete_graph.add_node(valve.name);
    }
    for valve in &all_valves {
        for &neighbor in &valve.neighbors {
            complete_graph.add_edge(valve.name, neighbor, ());
        }
    }

    let start = [b'A', b'A'];
    let interesting_valve_names: HashSet<_> = all_valves
        .iter()
        .filter(|valve| valve.name == start || valve.flow > 0)
        .map(|valve| valve.name)
        .collect();
    let mut interesting_valves = HashMap::new();
    for valve in &all_valves {
        if interesting_valve_names.contains(&valve.name) {
            let mut connected_valves = HashMap::new();
            for (another_valve, distance) in dijkstra(&complete_graph, valve.name, None, |_| 1) {
                if another_valve != start && interesting_valve_names.contains(&another_valve) {
                    connected_valves.insert(another_valve, distance);
                }
            }
            interesting_valves.insert(
                valve.name,
                Valve {
                    flow: valve.flow,
                    connected_valves,
                },
            );
        }
    }

    let valves_flow = interesting_valves.values().map(|valve| valve.flow).sum();

    let best_part_1 = &mut None;
    search_graph(
        &interesting_valves,
        &mut HashSet::new(),
        valves_flow,
        &[ValveOpener {
            goal: Some(Goal {
                name: start,
                remaining_time: 30,
            }),
        }],
        0,
        best_part_1,
    );
    let part_1 = best_part_1.unwrap() as i64;

    let best_part_2 = &mut None;
    search_graph(
        &interesting_valves,
        &mut HashSet::new(),
        valves_flow,
        &[
            ValveOpener {
                goal: Some(Goal {
                    name: start,
                    remaining_time: 26,
                }),
            },
            ValveOpener {
                goal: Some(Goal {
                    name: start,
                    remaining_time: 26,
                }),
            },
        ],
        0,
        best_part_2,
    );
    let part_2 = best_part_2.unwrap() as i64;

    (part_1, part_2).into()
}

fn parse_valve(input: &[u8]) -> PResult<ParsedValve> {
    map(
        tuple((
            tag(b"Valve "),
            parse_name,
            tag(b" has flow rate="),
            nom_i32,
            parse_neighbors,
        )),
        |(_, name, _, flow, neighbors)| ParsedValve {
            name,
            flow,
            neighbors,
        },
    )(input)
}

fn parse_neighbors(input: &[u8]) -> PResult<Vec<ValveName>> {
    alt((
        preceded(
            tag(b"; tunnels lead to valves "),
            separated_list1(tag(b", "), parse_name),
        ),
        map(
            preceded(tag(b"; tunnel leads to valve "), parse_name),
            |name| vec![name],
        ),
    ))(input)
}

fn parse_name(input: &[u8]) -> PResult<ValveName> {
    map(take(2usize), |name: &[u8]| [name[0], name[1]])(input)
}

#[derive(Debug, Copy, Clone)]
struct ValveOpener {
    // The valve this opener is heading to. Once `None` is means that the opener finished their run
    goal: Option<Goal>,
}

#[derive(Debug, Copy, Clone)]
struct Goal {
    /// The candidate valve
    name: ValveName,
    /// The number of minutes remaining after opening this valve
    remaining_time: i32,
}

#[derive(Debug, Copy, Clone)]
struct Candidate {
    goal: Option<Goal>,
    /// The valve's flow
    flow: i32,
    /// The total additional flow generated by opening this valve
    total_flow: i32,
    /// The maximum flow that can be generated by opening all other valves
    acc_total_flow_upper_bound: i32,
}

fn search_graph<const N: usize>(
    valves: &HashMap<ValveName, Valve>,
    chosen_valves: &mut HashSet<ValveName>,
    // The flow generated by all valves that were not yet chosen
    non_chosen_valves_flow: i32,
    openers: &[ValveOpener; N],
    acc_total_flow: i32,
    best_acc_total_flow: &mut Option<i32>,
) {
    const TIME_TO_OPEN_VALVE: i32 = 1;

    // Consider the opener that arrives first at their next valve
    let opener = openers
        .iter()
        .enumerate()
        .filter_map(|(i, opener)| opener.goal.map(|goal| (i, goal)))
        .max_by_key(|(_, opener)| opener.remaining_time);

    let (opener_index, opener_goal) = match opener {
        None => {
            return finish_search(acc_total_flow, best_acc_total_flow);
        }
        Some(opener) => opener,
    };

    // Find when the next-to-be-available opener is
    let next_opener_remaining_time = openers
        .iter()
        .enumerate()
        .filter_map(|(i, opener)| match opener.goal {
            Some(goal) if i != opener_index => Some(goal.remaining_time),
            _ => None,
        })
        .max()
        .unwrap_or(0);

    // List all possible next valve goals
    let other_valves = valves[&opener_goal.name]
        .connected_valves
        .iter()
        .filter_map(|(&name, &distance)| {
            let new_remaining_time = opener_goal.remaining_time - distance - TIME_TO_OPEN_VALVE;
            if chosen_valves.contains(&name) || new_remaining_time <= 0 {
                return None;
            }

            let valve_flow = valves[&name].flow;
            let total_flow = valve_flow * new_remaining_time;

            // The bound scenario is: an opener that can reach all remaining valves at once
            // immediately. This opener is the first between this one and all the others.
            let non_chosen_valves_flow = non_chosen_valves_flow - valve_flow;
            let bound_remaining_time = next_opener_remaining_time.max(new_remaining_time);
            let acc_total_flow_upper_bound = acc_total_flow
                + total_flow
                + non_chosen_valves_flow * (bound_remaining_time - TIME_TO_OPEN_VALVE).max(0);

            let goal = Goal {
                name,
                remaining_time: new_remaining_time,
            };
            Some(Candidate {
                goal: Some(goal),
                flow: valve_flow,
                total_flow,
                acc_total_flow_upper_bound,
            })
        });

    // This opener can also decide to stop their run now. This is a good option, for example, if
    // some other opener is much closer to the last valve to open. It's better to let them to it
    // in a next decision cycle
    let do_nothing = iter::once(Candidate {
        goal: None,
        flow: 0,
        total_flow: 0,
        acc_total_flow_upper_bound: acc_total_flow
            + non_chosen_valves_flow * (next_opener_remaining_time - TIME_TO_OPEN_VALVE).max(0),
    });

    // Sort the candidates by their estimated bounds: this tries to guide the visit of
    // higher-potential valves first.
    let candidates = other_valves
        .chain(do_nothing)
        .sorted_by_key(|candidate| Reverse(candidate.acc_total_flow_upper_bound));

    for candidate in candidates {
        if let Some(best) = best_acc_total_flow {
            if candidate.acc_total_flow_upper_bound <= *best {
                // Cut this branch because it is guaranteed to give worst results than the best
                // so far
                continue;
            }
        }

        if let Some(goal) = candidate.goal {
            chosen_valves.insert(goal.name);
        }
        let mut new_openers = *openers;
        new_openers[opener_index] = ValveOpener {
            goal: candidate.goal,
        };
        search_graph(
            valves,
            chosen_valves,
            non_chosen_valves_flow - candidate.flow,
            &new_openers,
            acc_total_flow + candidate.total_flow,
            best_acc_total_flow,
        );
        if let Some(goal) = candidate.goal {
            chosen_valves.remove(&goal.name);
        }
    }
}

fn finish_search(acc_total_flow: i32, best_acc_total_flow: &mut Option<i32>) {
    match best_acc_total_flow {
        None => *best_acc_total_flow = Some(acc_total_flow),
        Some(best) if *best < acc_total_flow => *best = acc_total_flow,
        _ => {}
    }
}
